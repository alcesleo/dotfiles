snippet class
class ${1:`!p snip.rv = "".join(map(lambda s:s.capitalize(), fn[:-3].split("_")))`}
  ${0:${VISUAL:# ...}}
end
endsnippet

snippet module
module ${1:`!p snip.rv = "".join(map(lambda s:s.capitalize(), path.split("/")[-2].split("_")))`}$0
  ${VISUAL:# ...}
end
endsnippet

snippet def
def ${1:method_name}(${2:args})
  ${3:fail NotImplementedError}$0
end
endsnippet

snippet defs
def self.${1:class_method_name}(${2:args})
  ${3:fail NotImplementedError}$0
end
endsnippet

snippet defi "initialize method"
`!p ruby_args = r"(\w+)(?:: \w+)?"
`def initialize($1)`!p
snip.shift();
for m in re.findall(ruby_args, t[1]):
    snip.rv += snip.mkline("\n")
    snip.rv += snip.mkline("@{0} = {0}".format(m))`
end
endsnippet

snippet defia "initialize method with attribute readers"
`!p
ruby_args          = r"(\w+)(?:: \w+)?"
ruby_args_symbols  = ", ".join(map(lambda arg: ":" + arg, re.findall(ruby_args, t[1])))
`attr_reader `!p snip.rv += ruby_args_symbols`

def initialize($1)`!p
snip.shift();
for m in re.findall(ruby_args, t[1]):
    snip.rv += snip.mkline("\n")
    snip.rv += snip.mkline("@{0} = {0}".format(m))`
end
endsnippet

snippet defiap "initialize method with private attribute readers"
`!p
ruby_args          = r"(\w+)(?:: \w+)?"
ruby_args_symbols  = ", ".join(map(lambda arg: ":" + arg, re.findall(ruby_args, t[1])))
`attr_reader `!p snip.rv += ruby_args_symbols`
private `!p snip.rv += ruby_args_symbols`

def initialize($1)`!p
snip.shift();
for m in re.findall(ruby_args, t[1]):
    snip.rv += snip.mkline("\n")
    snip.rv += snip.mkline("@{0} = {0}".format(m))`
end
endsnippet

snippet aa
attr_accessor :${1:instance_variable}
endsnippet

snippet ar
attr_reader :${1:instance_variable}
endsnippet

snippet aw
attr_writer :${1:instance_variable}
endsnippet

snippet alias "Lexical aliasing"
alias ${1:new} ${2:old}
endsnippet

snippet alias_method "Dynamic aliasing"
alias_method :${1:new}, :${2:old}
endsnippet

snippet do
do |${1:args}|
  $0
end
endsnippet

snippet {
{ |${1:args}|
endsnippet

snippet @
@${1:instance_var} = $1
endsnippet

snippet source
source "https://rubygems.org"
endsnippet

snippet load_path
lib = File.expand_path('../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
endsnippet

snippet rr "require_relative"
require_relative "$1"
endsnippet

snippet pry "Start pry here"
require "pry"; binding.pry
endsnippet

snippet bye "Start byebug here"
require "byebug"; byebug
endsnippet

snippet deb "Start ruby-debug here"
require "ruby-debug"; debugger
endsnippet

### Testing ###

snippet desc
describe "${1:feature}" do
  ${VISUAL}$0
end
endsnippet

snippet descf
describe `!p snip.rv = "".join(map(lambda s:s.capitalize(), fn[:-8].split("_")))` do
  ${VISUAL}$0
end
endsnippet

snippet rdesc "Insert require and describe based on path"
require "./`!p snip.rv = re.match(r"spec/(.*)_spec.rb", path).group(1)`"

describe `!p snip.rv = "".join(map(lambda s:s.capitalize(), fn[:-8].split("_")))` do
  $0
end
endsnippet

snippet it
it "${1:does something}" do
  ${VISUAL}$0
end
endsnippet

snippet let
let(:${1:var}) { ${2:double} }
endsnippet

snippet exp
expect(${1:${VISUAL:subject}}).${2:to} ${3:eq} ${4:expectation}
endsnippet

snippet subj
subject { ${1:described_class.new}$2 }
endsnippet

snippet task "Create a rake task"
desc "${1:Describe the task}"
task :${2:task_name} do
  $0
end
endsnippet

snippet rtask "Run rspec as default rake task"
require "rspec/core/rake_task"
RSpec::Core::RakeTask.new(:spec)
task :default => :spec
endsnippet

snippet minispec "MiniTest spec template"
require "minitest/spec"
require "minitest/autorun"

describe ${1:ClassName} do
  it "${2:does something}" do
    $0
  end
end
endsnippet

snippet minitest "MiniTest template"
require "minitest/autorun"

class ${1:TestName}Test < Minitest::Test
  $0
end
endsnippet

snippet t "Define test method"
def test_${1:that_it_works}
  $0
end
endsnippet

snippet a "assert"
assert(${2:actual})
endsnippet

snippet ae "assert_equal"
assert_equal(${1:expectation}, ${2:actual})
endsnippet

snippet r "refute"
refute(${2:actual})
endsnippet

snippet re "refute_equal"
refute_equal(${1:expectation}, ${2:actual})
endsnippet
